/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdlib.h>
#include "crypto.h"
#include <openssl/sha.h>

database db = {
	.currentTransaction = NULL,
	.table = NULL,
	.tam = 0
};

transaction* create_transaction(){
	transaction* new = (transaction*)malloc(sizeof(transaction));
	new->id = db.tam;
	new->winner = -1;
	new->challenge = rand() % 120;
	new->seed = rand() % 1000;
	db.table[db.tam] = new;
	db.currentTransaction = new;
	db.tam = db.tam + 1;

	return new;
}

void database_init(){	
	db.currentTransaction = NULL;
	for (int i = 0; i < 1000; i++){
		db.table[i] = NULL;	
	}
	db.tam = 0;		

	create_transaction();
}

int find(int transactionID){
	for (int i = 0; i < db.tam; i++){
		if(db.table[i]->id == transactionID){			
			return i;
		}	
	}
	return -1;
}

void get_reverse_binary(unsigned char* hash, int* result){	
	int j=0, cont;
	for (int i = 0; i < 20; i++){
		int n = hash[i];        
		cont = 0;
		for(;n>0;j++){    
			result[j]=n%2;    
			n=n/2;    
			cont++;            
		}  
		for (int k = cont; k < 8; k++){
			result[j] = 0;            
			j++;
		}        
	}	
}

int* gettransactionid_100_svc(void *argp, struct svc_req *rqstp){		
	if(db.tam == 0){
		database_init();			
	}	
	
	if(db.currentTransaction == NULL){
		create_transaction();
	}	
		
	static int result;
	result = db.currentTransaction->id;

	return &result;
}

int* getchallenge_100_svc(int *argp, struct svc_req *rqstp){
	static int result;

	if(db.tam != 0){		
		int i = find(*argp);
		if(i >= 0){
			result = db.table[i]->challenge;				
		}
		else result = -1;
	}	
	else{
		database_init();
		result = *getchallenge_100_svc(argp, rqstp);
	}	

	return &result;
}

int* gettransactionstatus_100_svc(int *argp, struct svc_req *rqstp){
	static int result;

	if(db.tam != 0){
		int i = find(*argp);
		if(i >= 0){
			if(db.table[i]->winner >= 0){
				result = 0;
			}
			else result = 1;				
		}
		else result = -1;
	}
	else{
		database_init();
		result = *gettransactionstatus_100_svc(argp, rqstp);
	}	

	return &result;
}

int* submitchallenge_100_svc(submit *argp, struct svc_req *rqstp){
	static int result;

	int transactionID = argp->transactionID;
	char seedC[SHA_DIGEST_LENGTH];
	sprintf(seedC,"%d",argp->seed);
	int lengthC = strlen(seedC);
	int clientID = argp->ClientID;

	printf("Seed Client: %d\n", argp->seed);

	int* transStatus = gettransactionstatus_100_svc(&transactionID, rqstp);
	if(*transStatus == 0){ // já resolvido
		result = 2;
		return &result;
	}	
	if(*transStatus == -1){ // inválido
		result = -1;
		return &result;
	}

	int idx = find(transactionID);
	transaction* t = db.table[idx];
	char seedT[SHA_DIGEST_LENGTH];
	sprintf(seedT, "%d", t->seed);
	int lengthT = strlen(seedT);

	unsigned char hashT[SHA_DIGEST_LENGTH];
	SHA1(seedT, lengthT, hashT);
	printf("Hash Transaction:\n");
	for (size_t i = 0; i < 20; i++){
    	printf("%02x", hashT[i]);
	}
	printf("\n");

	unsigned char hashC[SHA_DIGEST_LENGTH];
	SHA1(seedC, lengthC, hashC);
	printf("Hash Client:\n");
	for (size_t i = 0; i < 20; i++){
    	printf("%02x", hashC[i]);
	}
	printf("\n");

	// compare hashC and hashT
	int challenge = *getchallenge_100_svc(&transactionID, rqstp);

	int clientReverseBinary[160];
	get_reverse_binary(hashC, clientReverseBinary);

	int transactionReverseBinary[160];
	get_reverse_binary(hashT, transactionReverseBinary);


	for (int i = 0; i < challenge; i++){
		if(clientReverseBinary[i] != transactionReverseBinary[i]){		
			printf("Seed invalido\n\n");
			result = 0;
			return &result;
		}
	}
	
	// se funcionou
	db.currentTransaction->winner = argp->ClientID;
	db.currentTransaction = NULL;
	result = 1;

	return &result;
}

int* getwinner_100_svc(int *argp, struct svc_req *rqstp){
	static int  result;

	if(db.tam != 0){
		int i = find(*argp);
		if(i >= 0){			
			result = db.table[i]->winner;						
			if(result == -1)
				result = 0;
		}
		else result = -1;
	}
	else{
		database_init();
		result = *getwinner_100_svc(argp, rqstp);
	}

	return &result;
}

int* getseed_100_svc(int *argp, struct svc_req *rqstp){
	static int  result;

	if(db.tam != 0){
		int i = find(*argp);
		if(i >= 0){			
			if(db.table[i]->winner >= 0)
				result = db.table[i]->seed;
			else result = -1;
		}
		else result = -1;
	}
	else{
		database_init();
		result = *getseed_100_svc(argp, rqstp);
	}

	return &result;
}

void* minerar_100_svc(void *argp, struct svc_req *rqstp){

}
